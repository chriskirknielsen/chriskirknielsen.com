---
title: Designs
subtitle: A collection of posters and shirt designs I've made, available across multiple print-on-demand shops.
summary: Shirt, poster and sticker designs by Christopher Kirk-Nielsen
bigboiCta: { url: '/designs.xml', icon: 'rss', label: 'Design Feed' }
rssFeedOverride: '/designs.xml'
---

{% set activeDesigns = designs | selectattr('showInGallery') %}
{% set enableViewTransitions = false %}
{% set viewTransitionDuration %}300ms{% endset %}

<div class="u-textAlign-center">
	<h2 class="visually-hidden" id="designs-shops-label">Shops</h2>
	<ul class="inline-list | u-fontWeight-bold u-fontSize-smallest" style="--lh:var(--C-base-line-height)" aria-labelledby="designs-shops-label">
		{% for merchStore, merchUrl in metadata.merch %}
			{% set storeIconName %}store-icon-{{ merchStore | lower }}{% endset %}
			{% if merchStore == 'CottonBureau' %}
				<li hidden>{% svg storeIconName, { class: 'store-icon', id: storeIconName } %}</li>
			{% else %}
			<li class="store-item">
				<a href="{{ merchUrl | url }}">
					{% svg storeIconName, { class: 'store-icon', id: storeIconName } %}
					{{ merchStore }}
				</a>
			</li>
			{% endif %}
		{% endfor %}
	</ul>
</div>

<hr>

<filtered-tiles item-template="filter-item" filters="{{ activeDesigns | pluck('tags') | flatten | unique | sort | join(",") }}" filter-class="u-marginBlockEnd-xl" input-name="filter">
	<div class="gridlist" style="--spaced-items-gap:var(--size-m);">
	{% for design in activeDesigns %}
		{% set designPermalink = '/designs/' + design.slug + '/' | url %}
		{% set designAttrs %}
			id="{{ design.slug }}"
			{% if enableViewTransitions %}style="view-transition-name:{{ design.slug }}"{% endif %}
			data-tags="{%- for tag in design.tags -%}
				{{ tag }}
				{%- if not loop.last %},{% endif -%}
			{%- endfor -%}"
			aria-hidden="false"
		{% endset %}
		{% setAsync "designVariant" -%}
			{% if design.variant %}
				<div class="cardblock-badge | spaced-items inlined-items">
					{% svg "arrow-bidir", { class: "inline-icon" } %}
					<span>Variant available</span>
				</div>
			{% endif %}
		{%- endsetAsync %}
		{% set designLinks %}
			<ul role="list" class="spaced-items inlined-items | u-marginBlockStart-auto u-fontSize-smallest" {% if enableViewTransitions %}style="view-transition-name:{{ design.slug }}-list;"{% endif %}>
				{%- for site, url in design.links %}
				{% set siteIconId %}store-icon-{{ site | lower }}{% endset %}
				<li>
					<a href="{{ url | url }}" class="store-icon-linkwrap | u-display-block">
						<span class="visually-hidden">Get on {{ site }}</span>
						<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 1080 1080" class="store-icon-inline" aria-hidden="true">
							<title>{{ site }}</title>
							<use href="#{{ siteIconId }}" fill="currentColor" />
						</svg>
					</a>
				</li>
				{% endfor -%}
			</ul>
		{% endset%}

		{% component "griditem", {
			gridItem: design,
			gridItemAttrs: designAttrs,
			gridItemTitle: design.name,
			gridItemTitleSpacer: 'm',
			gridItemImage: '/' + assets.imagesDir + '/designs/' + design.img,
			gridItemPermalink: designPermalink,
			gridCoverlink: false,
			gridItemContent: designLinks,
			gridItemLazyImage: loop.index >= 8,
			gridItemImageDecorator: designVariant
		} %}
	{% endfor %}
	</div>
</filtered-tiles>

<template id="filter-item">
	<div class="filtering-item">
		<input type="radio" class="visually-hidden">
		<label class="filtering-tag | cta"></label>
	</div>
</template>

{% if enableViewTransitions %}
<style>
	{% set designsStyles %}
	* {
		view-transition-name: none;
	}

	::view-transition {
		pointer-events: none;
	}

	::view-transition-old(*),
	::view-transition-new(*) {
		animation-timing-function: var(--t-custom-easing, cubic-bezier(0.67, 0, 0.33, 1));
		animation-duration: {{ viewTransitionDuration }};
	}

	/* Entry transition */
	::view-transition-new(*):only-child {
		animation: fadeIn {{ viewTransitionDuration }} cubic-bezier(0.075, 0.82, 0.165, 1) both;
	}
	@keyframes fadeIn {
		0% {
			transform: scale(0.5);
			opacity: 0;
		}
		100% {
			opacity: 1;
			transform: scale(1);
		}
	}

	::view-transition-group:has(::view-transition-new(*):only-child) {
		z-index: 10;
	}
	::view-transition-group:has(::view-transition-old(*):only-child) {
		z-index: 0;
	}

	/* Exit transition */
	::view-transition-old(*):only-child {
		animation: fadeOut {{ viewTransitionDuration }} cubic-bezier(0.6, 0.04, 0.98, 0.335) both;
	}
	@keyframes fadeOut {
		0% {
			transform: scale(1);
			opacity: 1;
		}
		100% {
			transform: scale(0);
			opacity: 0;
		}
	}

	.footer {
		view-transition-name: footer;
	}
	{% endset %}
	{{- designsStyles | safe -}}
</style>
{% endif %}

<script>
{% set designsFilter %}
function filterTiles(context, inputName) {
	let hashIndicator = 'filter:';
	let initialHash = window.location.hash.slice(1);
	let items = Array.from(context.querySelectorAll('[data-tags]'));
	let list = context.querySelector('[data-filtered-list]');
	let tagList = Array.from(context.querySelectorAll('.filtering-item'));

	function resetItem(item) {
		item.style.width = '';
		item.style.height = '';
		item.removeAttribute('data-first');
		item.removeAttribute('data-shown-from-to');
		item.getAnimations().forEach((anim) => anim.cancel());
	}

	function filterTo(filter, skipAnim = false) {
		let isShowAll = filter === '';
		let filterHash = filter ? '#' + hashIndicator + filter : '';
		let prefersReducedMotion = window.matchMedia('(prefers-reduced-motion: reduce)').matches;
		let useViewTransitions = {% if enableViewTransitions %}true{% else %}false{% endif %};

		history.replaceState(undefined, '', filterHash);
		sessionStorage.setItem('designHash', filterHash);

		// Don't animate in certain conditions
		if (skipAnim || prefersReducedMotion || !Element.prototype.animate || (useViewTransitions && document.startViewTransition)) {
			const doViewTransition = !skipAnim && !prefersReducedMotion && useViewTransitions && document.startViewTransition;
			const updateFilteredItems = () => {
				const visibleWidth = items.find((i) => i.getAttribute('aria-hidden') !== 'true').getBoundingClientRect().width;
				items.forEach(function (item) {
					let tags = item.getAttribute('data-tags').split(',');
					let wasShown = item.getAttribute('aria-hidden') === 'false';
					let isShown = tags.indexOf(filter) > -1 || isShowAll;

					item.hidden = true;
					let afterHidden = () => {
						item.setAttribute('aria-hidden', (!isShown).toString());
						item.hidden = false;
					}

					if (skipAnim || prefersReducedMotion) {
						// RAF avoids a flash of positioned blocks when there is a filter on page load
						requestAnimationFrame(afterHidden);
					} else {
						afterHidden();
					}

					if (doViewTransition) {
						item.style.width = isShown ? '' : `${visibleWidth}px`;
						item.style.transition = isShown ? '' : 'none';
						item.style.viewTransitionName = isShown ? item.getAttribute('id') : `none`;
						item.querySelector('ul').style.viewTransitionName = wasShown && isShown ? `${item.getAttribute('id')}-list` : `none`;
						// item.querySelector('.cardblock-content').style.viewTransitionName = (isShown) ? `${item.getAttribute('id')}-content` : `none`; // Causes the pseudo element in neotokyo to vanish
					}
				});
			};

			if (doViewTransition) {
				const transition = document.startViewTransition(updateFilteredItems);
				transition.finished.then(() => {
					items.forEach(function (item) {
						let isShown = item.getAttribute('aria-hidden') === 'false';

						if (isShown) {
							// Ensure the next transition is correctly played if going from visible to visible
							item.querySelector('ul').style.viewTransitionName = `${item.getAttribute('id')}-list`;
						}
					});
				});
			} else {
				updateFilteredItems();
			}
			return;
		}

		// Set up the FLIP (First-Last-Invert-Play) animation
		const animateOptions = {
			duration: 300,
			easing: getComputedStyle(items[0]).transitionTimingFunction || 'ease-in-out',
		};
		const listGeometry = list.getBoundingClientRect();
		const footerElement = document.querySelector('.footer');
		list.style.setProperty('--t', `${animateOptions.duration}ms`); // Sync up with CSS

		// First, capture the initial state
		items.forEach(function (item) {
			resetItem(item); // Reset if triggered mid-animation
			const tags = item.getAttribute('data-tags').split(',');
			const wasShown = item.getAttribute('aria-hidden') === 'false';
			const isShown = tags.indexOf(filter) > -1 || isShowAll;
			const first = item.getBoundingClientRect();
			item.setAttribute('data-first', JSON.stringify(first));
			item.setAttribute('data-shown-from-to', `${wasShown ? 1 : 0},${isShown ? 1 : 0}`);
		});
		const footerOffsetStart = footerElement.offsetTop;

		// Then apply the change so all objects can calculate their new geometry after the change (taking sibling position into account)
		items.forEach(function (item, i) {
			const shown = item
				.getAttribute('data-shown-from-to')
				.split(',')
				.map((i) => parseInt(i, 10));
			const isShown = shown[1] === 1;
			item.setAttribute('aria-hidden', (!isShown).toString());
		});
		const footerOffsetEnd = footerElement.offsetTop;

		// Finally, grab the new geometry for all items and apply animation
		items.forEach(function (item, i) {
			const shown = item
				.getAttribute('data-shown-from-to')
				.split(',')
				.map((i) => parseInt(i, 10));
			const wasShown = shown[0] === 1;
			const isShown = shown[1] === 1;
			const first = JSON.parse(item.getAttribute('data-first'));
			const last = item.getBoundingClientRect();
			const keyframeFrom = {};
			const keyframeTo = {};

			// Determine keyframes for each config
			if (wasShown && isShown) {
				// Move
				keyframeFrom.transform = `translate(${first.left - last.left}px, ${first.top - last.top}px)`;
				//keyframeFrom.width = `${first.width}px`;
				//keyframeFrom.height = `${first.height}px`;
				keyframeTo.transform = `translate(0, 0)`;
				//keyframeTo.width = `${last.width}px`;
				//keyframeTo.height = `${last.height}px`;
			} else if (wasShown && !isShown) {
				// Hide
				keyframeFrom.transform = `translate(${first.left - listGeometry.left}px, ${first.top - listGeometry.top}px) scale(1)`;
				keyframeFrom.opacity = '1';
				keyframeFrom.width = `${first.width}px`;
				keyframeFrom.height = `${first.height}px`;
				keyframeTo.transform = `translate(${first.left - listGeometry.left}px, ${first.top - listGeometry.top}px) scale(0)`;
				keyframeTo.opacity = '0';
				keyframeTo.width = `${first.width}px`;
				keyframeTo.height = `${first.height}px`;
			} else if (!wasShown && isShown) {
				// Reveal
				keyframeFrom.transform = `translate(${first.left - listGeometry.left}px, ${first.top - listGeometry.top}px) scale(0)`;
				keyframeFrom.opacity = '0';
				keyframeFrom.width = `${last.width}px`;
				keyframeFrom.height = `${last.height}px`;
				keyframeTo.transform = `translate(0, 0) scale(1)`;
				keyframeTo.opacity = '1';
				keyframeTo.width = `${last.width}px`;
				keyframeTo.height = `${last.height}px`;
			} else if (!wasShown && !isShown) {
				// Stay hidden
				keyframeFrom.transform = `scale(0)`;
				keyframeTo.transform = `scale(0)`;
			}

			const anim = item.animate([keyframeFrom, keyframeTo], animateOptions);
			anim.addEventListener('finish', (e) => resetItem(item));
		});
		const footerOffsetDelta = footerOffsetEnd - footerOffsetStart;
		footerElement.animate([{ transform: `translateY(${-1 * footerOffsetDelta}px)` }, { transform: 'translateY(0)' }], animateOptions);
	}

	if (initialHash.indexOf(hashIndicator) === 0) {
		let baseFilter = initialHash.slice(hashIndicator.length);
		let filterSelectBox = context.querySelector('#filter-' + (baseFilter || 'all'));
		if (!filterSelectBox) {
			baseFilter = '';
			filterSelectBox = context.querySelector('#filter-all');
		}
		filterSelectBox.checked = true;
		filterTo(baseFilter, true);
	}

	context.addEventListener('input', function (e) {
		let radio = e.target.closest(`[name="${inputName}"]`);
		if (!radio) {
			return;
		}
		let filter = radio.value;
		filterTo(filter);
	});
}

class FilteredTiles extends HTMLElement {
	constructor() {
		super();
	}

	connectedCallback() {
		if (!this.getAttribute('item-template')) {
			throw new Error('A template must be provided to create the filter elements.');
		}

		// Manipulate the component contents to be easier to interact with
		this.firstChild.setAttribute('data-filtered-list', '');
		Array.from(this.firstChild.children).forEach((c) => c.setAttribute('data-filtered-item', ''));

		// Grab all the relevant attributes
		const filters = this.getAttribute('filters').split(',').map((f) => f.trim().toLowerCase());
		const filterClass = this.getAttribute('filter-class') || '';
		const fieldsetLegend = this.getAttribute('filter-legend') || 'Filter';
		const filterAllLabel = this.getAttribute('filter-all-label') || 'All';
		const filterTemplate = this.getAttribute('item-template');
		const inputName = this.getAttribute('input-name') || 'filter';

		// Set up the fieldset
		const fieldset = Object.assign(document.createElement('fieldset'), { className: 'filtering' });
		if (filterClass) {
			fieldset.classList.add(filterClass);
		}

		// Set up the legend: once accessibly, and once for aesthetic reasons (not correctly stylable in all browsers)
		const legendAccessible = Object.assign(document.createElement('legend'), { className: 'visually-hidden', innerText: fieldsetLegend });
		const legendVisible = Object.assign(document.createElement('strong'), { ariaHidden: true, className: 'filtering-legend', innerText: fieldsetLegend });
		fieldset.appendChild(legendAccessible);
		fieldset.appendChild(legendVisible);

		// Set up each filter item in the provided list
		let template = document.getElementById(filterTemplate);
		const createFilter = (slug, label = null, checked = false) => {
			const newItemElement = template.content.cloneNode(true);
			const newItemRadio = newItemElement.querySelector('input');
			const newItemLabel = newItemElement.querySelector('label');

			const checkboxId = `filter-${(label || slug).toLowerCase()}`;
			newItemRadio.id = checkboxId;
			newItemRadio.name = inputName;
			newItemRadio.value = slug || '';
			newItemRadio.checked = checked;
			newItemLabel.setAttribute('for', checkboxId);
			newItemLabel.innerText = label || slug;

			return newItemElement;
		};

		const filterItems = [createFilter('', filterAllLabel, true)].concat(filters.map((f) => createFilter(f)));
		filterItems.forEach((f) => fieldset.appendChild(f.firstChild));

		// Finally add the created element into the DOM
		this.insertBefore(fieldset, this.firstChild);

		// Once we have created the elements, run the logic to process filters
		filterTiles(this, inputName);
	}
}
customElements.define('filtered-tiles', FilteredTiles);
{% endset %}
{{- designsFilter | jsmin | safe -}}
</script>
